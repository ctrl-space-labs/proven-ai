"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4747],{8487:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var t=n(4848),s=n(8453);const r={},a="SSI Issuer and Verifier",d={id:"ProvenAI - SDK/SSI",title:"SSI Issuer and Verifier",description:"This package contains the main classes for the SSI (Self-Sovereign Identity) module.",source:"@site/docs/2. ProvenAI - SDK/5-SSI.md",sourceDirName:"2. ProvenAI - SDK",slug:"/ProvenAI - SDK/SSI",permalink:"/proven-ai/docs/ProvenAI - SDK/SSI",draft:!1,unlisted:!1,editUrl:"https://github.com/ctrl-space-labs/proven-ai/tree/main/provenai-documentation/docs/2. ProvenAI - SDK/5-SSI.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ISCC",permalink:"/proven-ai/docs/ProvenAI - SDK/ISCC"},next:{title:"Utils",permalink:"/proven-ai/docs/ProvenAI - SDK/Utils"}},o={},l=[{value:"Converters",id:"converters",level:2},{value:"Issuer",id:"issuer",level:2},{value:"Credential Issuance API",id:"credential-issuance-api",level:4},{value:"Key Creation",id:"key-creation",level:3},{value:"generateKey",id:"generatekey",level:4},{value:"JWKKeyWrapper",id:"jwkkeywrapper",level:3},{value:"DID Issuer",id:"did-issuer",level:3},{value:"Methods",id:"methods",level:4},{value:"ProvenAIIssuer",id:"provenaiissuer",level:3},{value:"VerifiableCredentialBuilder",id:"verifiablecredentialbuilder",level:4},{value:"VerifiablePresentationBuilder",id:"verifiablepresentationbuilder",level:4},{value:"Verifiable Credential Model",id:"verifiable-credential-model",level:2},{value:"Schemas",id:"schemas",level:3},{value:"Verifiable Credential Subjects",id:"verifiable-credential-subjects",level:3},{value:"Attestation",id:"attestation",level:4},{value:"ID",id:"id",level:4},{value:"Verifier",id:"verifier",level:2},{value:"CredentialVerificationApi",id:"credentialverificationapi",level:3},{value:"CredentialVerifier",id:"credentialverifier",level:3},{value:"PresentationVerifier",id:"presentationverifier",level:4}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"ssi-issuer-and-verifier",children:"SSI Issuer and Verifier"}),"\n",(0,t.jsx)(i.p,{children:"This package contains the main classes for the SSI (Self-Sovereign Identity) module.\nIn the context of ProvenAI, the SSI module is used to generate:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"AI Agent's DID"}),"\n",(0,t.jsx)(i.li,{children:"Issue AI Agent's ID VC"}),"\n",(0,t.jsx)(i.li,{children:"Present the Agent's ID VC"}),"\n",(0,t.jsx)(i.li,{children:'Issue the "Permission to Use" VC of a document, to be used by the AI Agent.'}),"\n",(0,t.jsx)(i.li,{children:"Verify VCs like the above (Agent's ID VC, Permission to Use VC)"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"converters",children:"Converters"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"converters"})," package contains necessary converters for the SDK's functionalities. In the context of provenAI SDK the converters are responsible for transforming all the verifiable formats supported by provenAI in order to adhere to the ",(0,t.jsx)(i.a,{href:"https://www.w3.org/TR/vc-data-model/",children:"W3CVC"})," standard. The converters developed are:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"AgentIDConverter"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"DataOwnershipCredentialConverter"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"LegalEntityConverter"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"NaturalPersonConverter"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"PermissionOfUseConverter"})}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"issuer",children:"Issuer"}),"\n",(0,t.jsx)(i.p,{children:"The issuer package contains all the classes and methods responsible to issue Verifiable Credentials supported by provenAI."}),"\n",(0,t.jsx)(i.h4,{id:"credential-issuance-api",children:"Credential Issuance API"}),"\n",(0,t.jsxs)(i.p,{children:["This class sends a request to an OID4VC compliant, credential issuance API in order to issue a signed credential. In provenAI's context the ",(0,t.jsx)(i.a,{href:"https://docs.walt.id/issuer/api/getting-started",children:"WaltID issuer API"})," is used. The credentian issuance api functionality is described ",(0,t.jsx)(i.a,{href:"../SSI-Issuer-&-Verifier/Setup-Issuer-and-Verifiers#credential-issuance-api",children:"here"})]}),"\n",(0,t.jsx)(i.h3,{id:"key-creation",children:"Key Creation"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"KeyCreation"})," class provides a method for generating cryptographic key pairs based on a given ",(0,t.jsx)(i.code,{children:"KeyType"})," and character length using the Walt.id library."]}),"\n",(0,t.jsx)(i.h4,{id:"generatekey",children:"generateKey"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.KeyType;\nimport id.walt.crypto.keys.jwk.JWKKey;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        JWKKey jwkKey = KeyCreation.generateKey(KeyType.secp256k1, characterLength);\n        \n        System.out.println("Generated Key ID: " + jwkKey.getKeyId());\n    }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"generateKey()"})," method creates a new key pair based on a given KeyType and character length. In the ",(0,t.jsx)(i.code,{children:"KeyCreation"})," class also the ",(0,t.jsx)(i.code,{children:"JWKKeyMetadata()"})," is defined. The  ",(0,t.jsx)(i.code,{children:"JWKKeyMetadata()"})," is an instance of ",(0,t.jsx)(i.code,{children:"JwkKeyMeta"})," and receives as input the ",(0,t.jsx)(i.code,{children:"keyId"})," and the key ",(0,t.jsx)(i.code,{children:"characterLength"}),". The supported keyId values as provided in the waltid crypto are: ",(0,t.jsx)(i.code,{children:"JwkKey"}),", ",(0,t.jsx)(i.code,{children:"TSEKey"})," and ",(0,t.jsx)(i.code,{children:"OCIKey"}),". In the context of provenAI ",(0,t.jsx)(i.code,{children:"JwkKey"})," keys are issued. To generate the key the method generateBlocking  with inputs the keyType and the ",(0,t.jsx)(i.code,{children:"JwkKeyMetadata"})," is used from waltID's ",(0,t.jsx)(i.code,{children:"JWKkey"})," kotlin class."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'JwkKeyMeta metadata = new JwkKeyMeta("JWKKey",characterLength);\n'})}),"\n",(0,t.jsxs)(i.p,{children:["The supported key types are: ",(0,t.jsx)(i.code,{children:"Ed25519"}),", ",(0,t.jsx)(i.code,{children:"secp256k1"}),", ",(0,t.jsx)(i.code,{children:"secp256r1"})," and ",(0,t.jsx)(i.code,{children:"RSA"}),". In provenAI context we mainly work with ",(0,t.jsx)(i.code,{children:"secp256k1"})," because this format is supported by the blockchain environment we use/"]}),"\n",(0,t.jsx)(i.h3,{id:"jwkkeywrapper",children:"JWKKeyWrapper"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"JWKKeyWrapper"})," class is created to wrap the waltID crypto JWKKey class methods in java, because it is written in kotlin. This ensures interoperability of this kotlin class in Java."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.jwk.JWKKey;\nimport id.walt.crypto.keys.KeyType;\nimport dev.ctrlspace.provenai.ssi.issuer.JWKKeyWrapper;\nimport id.walt.crypto.KeyCreation;\n\n\npublic class Main {\n    public static void main(String[] args) {\n\n        public static void main(String[] args) {\n        // Initialize the JWKKeyWrapper\n        JWKKeyWrapper jwkKeyWrapper = new JWKKeyWrapper();\n\n        int characterLength = 2048; \n        JWKKey jwkKey = KeyCreation.generateKey(KeyType.secp256r1, characterLength);\n\n        // Export the key to JWK format\n        Object exportedJWK = jwkKeyWrapper.exportJWK(jwkKey);\n        System.out.println("Exported JWK: " + exportedJWK);\n\n        // Get the public part of the key\n        JWKKey publicKey = jwkKeyWrapper.getPublicKey(jwkKey);\n        System.out.println("Public Key: " + publicKey);\n\n        // Retrieve the key ID of the JWK key\n        Object keyId = jwkKeyWrapper.getKeyId(jwkKey);\n        System.out.println("Key ID: " + keyId);\n\n        // Check if the key has a private part\n        Boolean hasPrivateKey = jwkKeyWrapper.hasPrivateKey(jwkKey);\n        System.out.println("Has Private Key: " + hasPrivateKey);\n\n        // Get the key type \n        KeyType keyType = jwkKeyWrapper.getKeyType(jwkKey);\n        System.out.println("Key Type: " + keyType);\n\n        // Get the JWK string representation of the key\n        String jwkString = jwkKeyWrapper.getJwk(jwkKey);\n        System.out.println("JWK String: " + jwkString);\n\n        // Export the key to PEM format\n        Object exportedPem = jwkKeyWrapper.exportPem(jwkKey);\n        System.out.println("Exported PEM: " + exportedPem);\n\n        // Get the public key representation \n        Object publicKeyRepresentation = jwkKeyWrapper.getPublicKeyRepresentation(jwkKey);\n        System.out.println("Public Key Representation: " + publicKeyRepresentation);\n\n        // Retrieve the thumbprint of the JWK key \n        Object thumbprint = jwkKeyWrapper.getThumbprint(jwkKey);\n        System.out.println("Thumbprint: " + thumbprint);\n\n    }\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"did-issuer",children:"DID Issuer"}),"\n",(0,t.jsxs)(i.p,{children:["The DidIssuer class provides methods for creating and resolving Decentralized Identifiers (DIDs) using various key types and methods. It leverages the Walt ID services for DID management and includes functionality for both key-based and web-based DIDs. For this class's methods we leverage the ",(0,t.jsx)(i.code,{children:"WaltIdServiceInitUtils"})," methods from WaltID identity package and wrap the kotlin developed methods in Java to be able to use them in a springboot project.\nWith the ",(0,t.jsx)(i.code,{children:"DidIssuer"})," constructor  the ",(0,t.jsx)(i.code,{children:"WaltIdServiceInitUtils"})," is initialized, to access its methods. Also it initialized the necessary continuation object for Kotlin coroutines. [ref gia coroutines apo utils]"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"WaltIdServiceInitUtils.INSTANCE.initializeWaltIdServices();"})}),"\n",(0,t.jsx)(i.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"createDidFromKey"}),": Creating a DID from a Key Pair"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["This method creates a Decentralized Identifier (DID) from a provided key pair using the did",":key"," method."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.KeyType;\nimport id.walt.crypto.keys.jwk.JWKKey;\n\npublic class Main {\n    public static void main(String[] args) {\n        DidIssuer didIssuer = new DidIssuer();\n        JWKKey jwkKey = KeyCreation.generateKey(KeyType.RSA, characterLength);\n        DidResult didResult = didIssuer.createDidFromKey(KeyType.RSA, jwkKey);\n        \n        System.out.println("Created DID: " + didResult.getDid());\n    }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["After generating a key we can issue the DID generated from the key. The method ",(0,t.jsx)(i.code,{children:"createdDidFromKey()"})," from ",(0,t.jsx)(i.code,{children:"DidIssuer"}),". It creates a DID from the generated key (",(0,t.jsx)(i.code,{children:"jwkKey"}),") and the provided ",(0,t.jsx)(i.code,{children:"KeyType"}),". The object returned is a ",(0,t.jsx)(i.code,{children:"DidResult"}),". The ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," object must be initialized, tahat defines the parameters for the DID created. The necessary inputs are the ",(0,t.jsx)(i.code,{children:"keyType"})," and the boolean ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"}),". If the ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"})," flag is set to true, it applies the EBSI-specific jwk_jcs-pub encoding during the resolution process. To generate the DID, the method ",(0,t.jsx)(i.code,{children:"registerByKey"})," is used from ",(0,t.jsx)(i.code,{children:"DidService"})," The inputs needed is the generation method, dependent on the key provided, the key JWK, the ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," and a continuation object for kotlin coroutines. In the contect of provenAI the method is se to ",(0,t.jsx)(i.code,{children:'"key"'}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"createDidFromAutoKey"}),": This method creates a Decentralized Identifier (DID) using the did",":key"," method with a key that is generated internally. You specify the key type and the method handles the key creation."]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.KeyType;\n\npublic class Main {\n    public static void main(String[] args) {\n        DidIssuer didIssuer = new DidIssuer();\n        DidResult didResult = didIssuer.createDidFromAutoKey(KeyType.RSA);\n        \n        System.out.println("Created DID: " + didResult.getDid());\n    }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["The method ",(0,t.jsx)(i.code,{children:"createdDidFromKey()"})," from ",(0,t.jsx)(i.code,{children:"DidIssuer"}),". It creates a DID from the generated key (",(0,t.jsx)(i.code,{children:"jwkKey"}),") and the provided ",(0,t.jsx)(i.code,{children:"KeyType"}),". The object returned is a ",(0,t.jsx)(i.code,{children:"DidResult"}),". The ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," object must be initialized, tahat defines the parameters for the DID created. The necessary inputs are the ",(0,t.jsx)(i.code,{children:"keyType"})," and the boolean ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"}),". If the ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"})," flag is set to true, it applies the EBSI-specific jwk_jcs-pub encoding during the resolution process. To generate the DID, the method ",(0,t.jsx)(i.code,{children:"registerByKey"})," is used from ",(0,t.jsx)(i.code,{children:"DidService"})," The inputs needed is the generation method, dependent on the key provided, the key JWK, the ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," and a continuation object for kotlin coroutines. In the contect of provenAI the method is se to ",(0,t.jsx)(i.code,{children:'"key"'}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.strong,{children:"createDidFromWeb"})}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'public class Main {\n    public static void main(String[] args) {\n        DidIssuer didIssuer = new DidIssuer();\n        DidResult didResult = didIssuer.createDidFromWeb("example.com", "/did/doc", KeyType.RSA);\n        \n        System.out.println("Created DID: " + didResult.getDid());\n    }\n}\n\n'})}),"\n",(0,t.jsxs)(i.p,{children:["The method ",(0,t.jsx)(i.code,{children:"createDidFromWeb()"})," from ",(0,t.jsx)(i.code,{children:"DidIssuer"}),". It creates a DID from the ",(0,t.jsx)(i.code,{children:"domain"})," that serves the did document and the ",(0,t.jsx)(i.code,{children:"path"})," it is located. The object returned is a ",(0,t.jsx)(i.code,{children:"DidResult"}),". The ",(0,t.jsx)(i.code,{children:"DidWebCreateOptions"})," object must be initialized, tahat defines the parameters for the DID created. The necessary inputs are the ",(0,t.jsx)(i.code,{children:"domain"}),", the ",(0,t.jsx)(i.code,{children:"path"})," and the ",(0,t.jsx)(i.code,{children:"KeyType"}),". To generate the DID, the method ",(0,t.jsx)(i.code,{children:"registerBlocking"})," is used from ",(0,t.jsx)(i.code,{children:"DidService"})," The input needed is the ",(0,t.jsx)(i.code,{children:"DidWebCreateOptions"}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"resolveKeyDidToKey"}),": This method resolves a key-based DID to its key. This method accepts a key type and resolves the given JSON Web Key (JWK) to its associated DID."]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.KeyType;\nimport id.walt.crypto.keys.jwk.JWKKey;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        DidIssuer didIssuer = new DidIssuer();\n        \n        // Generate a JWKKey\n        JWKKey jwkKey = KeyCreation.generateKey(KeyType.secp256k1, characterLength);\n\n        DidResult didResult = didIssuer.resolveKeyDidToKey(KeyType.secp256k1, false, jwkKey);\n\n        System.out.println("Resolved Key DID: " + didResult.getDid());\n    }\n}\n\n'})}),"\n",(0,t.jsxs)(i.p,{children:["After generating a key we can resolve the DID generated to that key. The method used is ",(0,t.jsx)(i.code,{children:"resolveKeyDidToKey()"})," from ",(0,t.jsx)(i.code,{children:"DidIssuer"}),". It resolves a DID from the generated key (",(0,t.jsx)(i.code,{children:"jwkKey"}),") and the provided ",(0,t.jsx)(i.code,{children:"KeyType"})," and the flag ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"}),". The object returned is a ",(0,t.jsx)(i.code,{children:"DidResult"}),". The ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," object must be initialized. The necessary inputs are the ",(0,t.jsx)(i.code,{children:"keyType"})," and the boolean ",(0,t.jsx)(i.code,{children:"useJwkJcsPub"}),". To resolve the DID, the method ",(0,t.jsx)(i.code,{children:"createByKeyBlocking"})," is used from ",(0,t.jsx)(i.code,{children:"LocalRegistrar"})," The inputs needed is the generation method, dependent on the key provided, the key JWK, the ",(0,t.jsx)(i.code,{children:"DidKeyCreateOptions"})," and they key JWK."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"resolveWebDidToKey"}),": This method resolves a web-based DID to its key and resolves the given JSON Web Key (JWK) to its associated DID."]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.crypto.keys.KeyType;\nimport id.walt.crypto.keys.jwk.JWKKey;\n\npublic class Main {\n    public static void main(String[] args) {\n\nDidIssuer didIssuer = new DidIssuer();\n        \n        JWKKey jwkKey = KeyCreation.generateKey(KeyType.secp256k1, characterLength);\n\n        // Resolve the DID to the key using web-based DID\n        DidResult didResult = didIssuer.resolveWebDidToKey(KeyType.secp256k1, "example.com", "/did-path", jwkKey);\n\n        // Output the resolved Web DID\n        System.out.println("Resolved Web DID: " + didResult.getDid());\n    }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["After generating a key we can resolve the DID generated to that key. The method used is ",(0,t.jsx)(i.code,{children:"resolveWebDidToKey()"})," from ",(0,t.jsx)(i.code,{children:"DidIssuer"}),". It resolves a DID from the generated key (",(0,t.jsx)(i.code,{children:"jwkKey"}),"), the provided ",(0,t.jsx)(i.code,{children:"domain"})," and ",(0,t.jsx)(i.code,{children:"path"}),". The object returned is a ",(0,t.jsx)(i.code,{children:"DidResult"}),". The ",(0,t.jsx)(i.code,{children:"DidWebCreateOptions"})," object must be initialized. To resolve the DID, the method ",(0,t.jsx)(i.code,{children:"createByKeyBlocking"})," is used from ",(0,t.jsx)(i.code,{children:"LocalRegistrar"})," The inputs needed is the generation method, dependent on the key provided, the key JWK, the ",(0,t.jsx)(i.code,{children:"DidWebCreateOptions"})," and they key JWK."]}),"\n",(0,t.jsx)(i.h3,{id:"provenaiissuer",children:"ProvenAIIssuer"}),"\n",(0,t.jsx)(i.h4,{id:"verifiablecredentialbuilder",children:"VerifiableCredentialBuilder"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"VerifiableCredentialBuilder"})," class provides a flexible way to create verifiable credentials in compliance with the W3C Verifiable Credentials (VC) standard. It allows users to define the context, types, issuer, validity, subject, and other properties of the credential, and provides a method to sign the credential with a key. To generate the verifiable credential this class wraps the methods developed in WaltID's kotlin class ",(0,t.jsx)(i.code,{children:"CredentialBuilder"}),". Hence we need to initialize the credential builder setting the ",(0,t.jsx)(i.code,{children:"credentialBuilderType"})," to ",(0,t.jsx)(i.code,{children:"W3CV11CredentialBuilder"}),", in the ",(0,t.jsx)(i.code,{children:"VerifiableCredentialBuilder"})," constructor. An example implementation is presented below."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.credentials.vc.vcs.W3CVC;\nimport id.walt.crypto.keys.JWKKey;\nimport id.walt.crypto.keys.KeyType;\nimport kotlin.Pair;\nimport kotlinx.serialization.json.JsonElement;\nimport kotlinx.serialization.json.JsonObject;\nimport kotlinx.serialization.json.JsonPrimitive;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Initialize DidIssuer to generate DID for issuer and subject\n        DidIssuer didIssuer = new DidIssuer();\n\n        // Generate a JWK key for the issuer\n        JWKKey issuerKey = KeyCreation.generateKey(KeyType.secp256k1, 2048);\n        DidResult issuerDidResult = didIssuer.createDidFromKey(KeyType.secp256k1, issuerKey);\n        String issuerDid = issuerDidResult.getDid();  // Get the DID of the issuer\n\n        // Generate a JWK key for the subject\n        JWKKey subjectKey = KeyCreation.generateKey(KeyType.secp256k1, 2048);\n        DidResult subjectDidResult = didIssuer.createDidFromKey(KeyType.secp256k1, subjectKey);\n        String subjectDid = subjectDidResult.getDid();  // Get the DID of the subject\n\n        System.out.println("Issuer DID: " + issuerDid);\n        System.out.println("Subject DID: " + subjectDid);\n\n        // Initialize the verifiable credential builder\n        VerifiableCredentialBuilder vcBuilder = new VerifiableCredentialBuilder();\n\n        // Add context \n        vcBuilder.addContext("https://www.w3.org/2018/credentials/v1");\n\n        // Add types to the verifiable credential\n        vcBuilder.addType("VerifiableCredential");\n        vcBuilder.addType("EBSILegalEntityVerifiableID");\n\n        // Set the credential ID\n        vcBuilder.setCredentialId("urn:uuid:12345678-abcd-1234-abcd-1234567890ab");\n\n        // Set the issuer\'s DID\n        vcBuilder.setIssuerDid(issuerDid);\n\n        // Set the validity period\n        vcBuilder.validFromNow();  \n        vcBuilder.validFor(Duration.ofDays(365));  \n\n        // Define the credential subject \n        JsonObject subjectData = new JsonObject(Map.of(\n            "id", new JsonPrimitive(subjectDid),  \n            "legalName", new JsonPrimitive("Example Corp")\n        ));\n        vcBuilder.credentialSubject(subjectData);\n\n        // Set the subject\'s DID\n        vcBuilder.setSubjectDid(subjectDid);\n\n        // Add extra data to the credential\n        vcBuilder.useData(new Pair<>("someKey", new JsonPrimitive("someValue")));\n\n        // Build the verifiable credential\n        W3CVC vc = vcBuilder.buildCredential();\n\n        // Sign the verifiable credential\n        Map<String, String> additionalJwtHeaders = new HashMap<>();  // Additional JWT headers\n        Map<String, JsonElement> additionalJwtOptions = new HashMap<>();  // Additional JWT options\n\n        Object signedVc = vcBuilder.signCredential(\n            vc, \n            issuerKey,  // Use the issuer\'s key for signing\n            issuerDid,  // Issuer DID\n            subjectDid,  // Subject DID\n            additionalJwtHeaders, \n            additionalJwtOptions\n        );\n\n        // Output the signed verifiable credential\n        System.out.println("Signed Verifiable Credential: " + signedVc.toString());\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h4,{id:"verifiablepresentationbuilder",children:"VerifiablePresentationBuilder"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"VerifiablePresentationBuilder"})," class provides a flexible way to create a verifiable credential(s) presentation in compliance with the W3C standard. It allows users to define the subject, the nonce generation method the credential and the selection of how many and which credentials to include in the presentation. It and provides a method to sign the credential with a key. To generate the verifiable presentation this class wraps the methods developed in WaltID's kotlin class ",(0,t.jsx)(i.code,{children:"PresentationBuilder"}),". Hence we need to initialize the presentation builder, in the ",(0,t.jsx)(i.code,{children:"VerifiablePresentationBuilder"})," constructor. An example implementation is presented below."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import kotlinx.serialization.json.JsonElement;\nimport kotlinx.serialization.json.JsonPrimitive;\nimport id.walt.crypto.keys.JWKKey;\n\npublic class Main {\n    public static void main(String[] args) {\n        \n        Object signedVc = vcBuilder.signCredential(\n            vc, \n            issuerKey,  // Use the issuer\'s key for signing\n            issuerDid,  // Issuer DID\n            subjectDid,  // Subject DID\n            additionalJwtHeaders, \n            additionalJwtOptions\n        );\n\n        // Generate a JWK key for the subject\n        JWKKey subjectKey = KeyCreation.generateKey(KeyType.secp256k1, 2048);\n\n        DidResult subjectDidResult = didIssuer.createDidFromKey(KeyType.secp256k1, subjectKey);\n\n        String subjectDid = subjectDidResult.getDid();  // Get the DID of the subject\n\n        // Set Subject DID\n        vpBuilder.setDid(subjectDid);\n\n        // Set unique presentation ID\n        vpBuilder.setPresentationId();\n\n        // Set a nonce for the presentation (example)\n        vpBuilder.setNonce("random_nonce");\n\n        // Add the signed Verifiable Credential (VC) to the Verifiable Presentation (VP)\n        vpBuilder.addCredential(new JsonPrimitive(signedVc.toString()));\n\n        // Build the Verifiable Presentation JSON\n        JsonElement presentationJson = vpBuilder.buildPresentationJson();\n        System.out.println("Verifiable Presentation JSON: " + presentationJson.toString());\n\n        // Sign the Verifiable Presentation (VP) with the subject\'s key\n        Object signedPresentation = vpBuilder.buildAndSign(subjectKey);\n        System.out.println("Signed Verifiable Presentation: " + signedPresentation.toString());\n    }\n}\n\n'})}),"\n",(0,t.jsx)(i.h2,{id:"verifiable-credential-model",children:"Verifiable Credential Model"}),"\n",(0,t.jsxs)(i.p,{children:["This section provides documentation for the core classes representing Verifiable Credentials (VC) as defined by the W3C Verifiable Credentials Data Model. he ",(0,t.jsx)(i.code,{children:"CredentialSubject"})," interface defines the structure for the credentialSubject part of any Verifiable Credential. It includes an abstract method ",(0,t.jsx)(i.code,{children:"getId()"})," which must be implemented by any specific credential subject. The ",(0,t.jsx)(i.code,{children:"VerifiableCredential"})," class is a generic class used to define the structure of a Verifiable Credential. It is parameterized with ",(0,t.jsx)(i.code,{children:"T"}),", where ",(0,t.jsx)(i.code,{children:"T"})," must be a class that extends the ",(0,t.jsx)(i.code,{children:"CredentialSubject"})," interface."]}),"\n",(0,t.jsx)(i.h3,{id:"schemas",children:"Schemas"}),"\n",(0,t.jsx)(i.p,{children:"This package defines schemas for Verifiable Credentials (VCs) issued in the provenAI context, natural person, legal entity, data ownership, and AI agent. These JSON schemas are used to standardize how information is represented in verifiable credentials within decentralized and verifiable systems, such as those leveraging Distributed Ledger Technology (DLT) or Decentralized Identifiers (DIDs). Each schema complies with the JSON Schema Draft 2020-12 standard."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"natural-person.schema.json"})}),"\n",(0,t.jsx)(i.p,{children:"Purpose: Defines a Verifiable Credential (VC) for a natural person.\nRequired Fields:\nid: Unique identifier of the credential subject.\nfamilyName: The family name of the subject.\nfirstName: The first name of the subject.\ndateOfBirth: Date of birth (formatted as date)."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"legal-entity.schema.json"})}),"\n",(0,t.jsx)(i.p,{children:"Purpose: Defines a Verifiable Credential for legal entities, such as businesses or organizations.\nRequired Fields:\nid: Unique identifier of the credential subject.\nlegalName: Official legal name of the entity.\ndomaiName: Domain name of Credential Subject."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"data-ownership.schema.json"})}),"\n",(0,t.jsx)(i.p,{children:"Purpose: Describes a certificate that verifies the ownership of data by a data pod.\nRequired Fields:\ndataPodName: Name of the data pod.\ndataPodId: Unique identifier for the data pod.\nownershipStatus: Status of ownership (e.g., active or suspended).\nusagePolicies: An array of policies governing data usage.\nisccCollectionMerkleRoot: Merkle root for ISCC for a document section collection."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"verifiable-ai-agent.schema.json"})}),"\n",(0,t.jsx)(i.p,{children:"Purpose: Defines a schema for verifying AI agents, which may act autonomously or as part of a larger system.\nRequired Fields:\nid: Unique identifier of the credential subject.\norganizationName: Name of the organization responsible for the AI agent\nagentName: Name of the AI agent.\ncreationDate: Date the AI agent was created."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"permission-of-use.schema.json"})}),"\n",(0,t.jsx)(i.p,{children:"Purpose: Specifies the schema for permissions granted for the use of data or systems by an entity.\nRequired Fields:\nid: Unique identifier of the credential subject.\nownerID: Unique identifier (DID) of the data owner.\npolicies: List of all policies applicable to the data usage by the agent.\ndataSegments: List of ISCCs that the agent has the rights to use."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"verifiable-credential-subjects",children:"Verifiable Credential Subjects"}),"\n",(0,t.jsx)(i.h4,{id:"attestation",children:"Attestation"}),"\n",(0,t.jsx)(i.p,{children:"This package contains classes representing the credential subject part of attestation Verifiable Credentials (VCs). Each class is compliant with the W3C and EBSI standards for Verifiable Credentials and is used to define the entities and their attributes for attestation purposes."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"AIAgentCredentialSubject"}),"\nThis class defines the credential subject for an AI Agent Credential. It includes properties such as the organizationName, agentName, agentId, and a creationDate that represents the timestamp when the agent was created. The class also holds a list of usagePolicies, representing policies that govern the use of the agent."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"DataOwnershipCredentialSubject"}),"\nThis class represents the credential subject for Data Ownership Credentials. It defines fields such as the dataPodName, dataPodId, and ownershipStatus to track data pod ownership. Additional fields include usagePolicies, which defines the policies applied to the data pod, and isccCollectionMerkleRoot, which links to the ISCC (International Standard Content Code) collection associated with the data."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"PermissionOfUseCredentialSubject"}),"\nThis class defines the credential subject for a Permission of Use Credential. It includes the id (representing the DID of the AI agent), ownerDID (representing the data owner's DID), and a list of policies that describe the permissions related to the credential. The dataSegments field holds a list of ISCCs representing specific data segments covered by the credential."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"W3CCredentialSubject"}),"\nThis class defines the credential subject for a W3C Verifiable Credential. It includes a useData field represented as a Pair of string and JsonElement, allowing flexible, additional data to be attached to the credential. The credentialSubject field stores the actual subject of the credential in JSON format, following the W3C VC standards."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"id",children:"ID"}),"\n",(0,t.jsx)(i.p,{children:"This package contains classes representing the credential subject part for ID Verifiable Credentials (VCs). Each class is compliant with the W3C and EBSI standards for Verifiable Credentials and is used to define the entities and their attributes for attestation purposes."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"NaturalPersonCredentialSubject"}),"\nThis class represents the credential subject for a natural person. It includes fields such as id (representing the DID of the person), familyName, firstName, and other personal identifiers like dateOfBirth, yearOfBirth, and personalIdentifier. The class also includes placeOfBirth and currentAddress fields, represented by the Address class. The nationality field is a list of the person\u2019s nationalities."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"LegalEntityCredentialSubject"}),"\nThis class represents the credential subject for a legal entity. It includes fields like id (representing the DID of the legal entity), legalPersonIdentifier, legalName, and legalAddress. The class also contains fields such as VATRegistration, taxReference, and other legal identifiers like LEI (Legal Entity Identifier) and EORI (Economic Operators Registration and Identification). Additionally, the domainName field can either be a String or a List of Strings representing the domain names of the entity."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"verifier",children:"Verifier"}),"\n",(0,t.jsx)(i.h3,{id:"credentialverificationapi",children:"CredentialVerificationApi"}),"\n",(0,t.jsxs)(i.p,{children:["This class sends a request to an OID4VC compliant, credential verification API in order to verify a signed credential. In provenAI's context the ",(0,t.jsx)(i.a,{href:"https://docs.walt.id/verifier/api/getting-started",children:"WaltID verifier API"})," is used. The credential verifier API functionality is described in ",(0,t.jsx)(i.a,{href:"../SSI-Issuer-&-Verifier/Setup-Issuer-and-Verifiers#credential-verification-api",children:"here"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["his class sends a request to an OID4VC compliant, credential issuance API in order to issue a signed credential. In provenAI's context the ",(0,t.jsx)(i.a,{href:"https://docs.walt.id/issuer/api/getting-started",children:"WaltID issuer API"})," is used. The credentian issuance api functionality is described ",(0,t.jsx)(i.a,{href:"../SSI-Issuer-&-Verifier/Setup-Issuer-and-Verifiers#credential-issuance-api",children:"here"})]}),"\n",(0,t.jsx)(i.h3,{id:"credentialverifier",children:"CredentialVerifier"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"CredentialVerifier"})," class is responsible for verifying Verifiable Credentials (VCs) against a defined set of policies. This class uses the ",(0,t.jsx)(i.code,{children:"Verifier"})," from the waltID'S verfier. This class offers both asynchronous and synchronous methods for credential verification, utilizing Java's ",(0,t.jsx)(i.code,{children:"CompletableFuture"})," for non-blocking operations. We have ",(0,t.jsx)(i.code,{children:"verifyCredentialAsync"}),", which can verify a signed credential without blocking the calling thread, and ",(0,t.jsx)(i.code,{children:"verifyCredentialBlocking"}),", which can verify a signed credential in a blocking manner, which may be simpler in scenarios where immediate results are needed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.credentials.vc.vcs.W3CVC;\nimport id.walt.crypto.keys.JWKKey;\nimport id.walt.crypto.keys.KeyType;\nimport kotlin.Pair;\nimport kotlinx.serialization.json.JsonElement;\nimport kotlinx.serialization.json.JsonObject;\nimport kotlinx.serialization.json.JsonPrimitive;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Initialize DidIssuer to generate DID for issuer and subject\n        DidIssuer didIssuer = new DidIssuer();\n\n        // Generate a JWK key for the issuer\n        JWKKey issuerKey = KeyCreation.generateKey(KeyType.secp256k1, 2048);\n        DidResult issuerDidResult = didIssuer.createDidFromKey(KeyType.secp256k1, issuerKey);\n        String issuerDid = issuerDidResult.getDid();  // Get the DID of the issuer\n\n        // Generate a JWK key for the subject\n        JWKKey subjectKey = KeyCreation.generateKey(KeyType.secp256k1, 2048);\n        DidResult subjectDidResult = didIssuer.createDidFromKey(KeyType.secp256k1, subjectKey);\n        String subjectDid = subjectDidResult.getDid();  // Get the DID of the subject\n\n        System.out.println("Issuer DID: " + issuerDid);\n        System.out.println("Subject DID: " + subjectDid);\n\n        // Initialize the verifiable credential builder\n        VerifiableCredentialBuilder vcBuilder = new VerifiableCredentialBuilder();\n\n        // Add context \n        vcBuilder.addContext("https://www.w3.org/2018/credentials/v1");\n\n        // Add types to the verifiable credential\n        vcBuilder.addType("VerifiableCredential");\n        vcBuilder.addType("EBSILegalEntityVerifiableID");\n\n        // Set the credential ID\n        vcBuilder.setCredentialId("urn:uuid:12345678-abcd-1234-abcd-1234567890ab");\n\n        // Set the issuer\'s DID\n        vcBuilder.setIssuerDid(issuerDid);\n\n        // Set the validity period\n        vcBuilder.validFromNow();  \n        vcBuilder.validFor(Duration.ofDays(365));  \n\n        // Define the credential subject \n        JsonObject subjectData = new JsonObject(Map.of(\n            "id", new JsonPrimitive(subjectDid),  \n            "legalName", new JsonPrimitive("Example Corp")\n        ));\n        vcBuilder.credentialSubject(subjectData);\n\n        // Set the subject\'s DID\n        vcBuilder.setSubjectDid(subjectDid);\n\n        // Add extra data to the credential\n        vcBuilder.useData(new Pair<>("someKey", new JsonPrimitive("someValue")));\n\n        // Build the verifiable credential\n        W3CVC vc = vcBuilder.buildCredential();\n\n        // Sign the verifiable credential\n        Map<String, String> additionalJwtHeaders = new HashMap<>();  // Additional JWT headers\n        Map<String, JsonElement> additionalJwtOptions = new HashMap<>();  // Additional JWT options\n\n        Object signedVc = vcBuilder.signCredential(\n            vc, \n            issuerKey,  // Use the issuer\'s key for signing\n            issuerDid,  // Issuer DID\n            subjectDid,  // Subject DID\n            additionalJwtHeaders, \n            additionalJwtOptions\n        );\n\n        // Output the signed verifiable credential\n        System.out.println("Signed Verifiable Credential: " + signedVc.toString());\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h4,{id:"presentationverifier",children:"PresentationVerifier"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"PresentationVerifier"})," class is responsible for verifying Verifiable Credentials (VCs) against a defined set of policies. This class uses the ",(0,t.jsx)(i.code,{children:"Verifier"})," from the waltID'S verfier. This class offers both asynchronous and synchronous methods for credential verification, utilizing Java's ",(0,t.jsx)(i.code,{children:"CompletableFuture"})," for non-blocking operations. We have ",(0,t.jsx)(i.code,{children:"verifyPresentationAsync"}),", that performs verification in a non-blocking manner,, and ",(0,t.jsx)(i.code,{children:"verifyPresentationBlocking"}),", which performs verification in a blocking manner."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'import id.walt.credentials.verification.models.PolicyRequest;\nimport id.walt.credentials.verification.models.PresentationVerificationResponse;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic class PresentationVerificationExample {\n\n    public static void main(String[] args) {\n        // Create an instance of PresentationVerifier\n        PresentationVerifier verifier = new PresentationVerifier();\n\n        // Example signed presentation\n        String signedPresentation = "example_signed_presentation";\n\n        // Example policies for verification\n        List<PolicyRequest> vpPolicies = new ArrayList<>();\n        // Add verifiable presentation policies to the list as needed\n        // vpPolicies.add(new PolicyRequest(...));\n\n        List<PolicyRequest> globalVcPolicies = new ArrayList<>();\n        // Add global policies to the list as needed\n        // globalVcPolicies.add(new PolicyRequest(...));\n\n        HashMap<String, List<PolicyRequest>> specificCredentialPolicies = new HashMap<>();\n        // Add specific credential policies as needed\n        // specificCredentialPolicies.put("credentialId", new ArrayList<PolicyRequest>());\n\n        // Presentation context\n        HashMap<String, Object> presentationContext = new HashMap<>();\n        presentationContext.put("key", "value");\n\n        // Asynchronous verification\n        CompletableFuture<PresentationVerificationResponse> asyncResult = verifier.verifyPresentationAsync(\n                signedPresentation, vpPolicies, globalVcPolicies, specificCredentialPolicies, presentationContext);\n        \n        asyncResult.thenAccept(response -> {\n            System.out.println("Async Presentation Verification Result:");\n            System.out.println(response);\n        }).exceptionally(ex -> {\n            System.err.println("Error during async presentation verification: " + ex.getMessage());\n            return null;\n        });\n\n        // Synchronous verification\n        try {\n            PresentationVerificationResponse syncResponse = verifier.verifyPresentationBlocking(\n                    signedPresentation, vpPolicies, globalVcPolicies, specificCredentialPolicies, presentationContext);\n            System.out.println("Sync Presentation Verification Result:");\n            System.out.println(syncResponse);\n        } catch (Exception e) {\n            System.err.println("Error during sync presentation verification: " + e.getMessage());\n        }\n    }\n}\n'})})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>d});var t=n(6540);const s={},r=t.createContext(s);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);